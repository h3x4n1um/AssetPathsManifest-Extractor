#include "json.hpp"
#include <fstream>

using namespace std;
using namespace nlohmann;

void _error(){
    cerr << R"(Error! "AssetPathsManifest" not found or not correct format!!!)" << "\n\n";
    system("pause");
}

const string generate_info =R"(/********************************************************
*This file was generated by AssetPathsManifest Extractor*
*Version: 2.3.1                                         *
*Made by: H3x4n1um                                      *
********************************************************/
)";

ifstream input;
ofstream output;
json js, versions, patch;
string ls;
map <string, vector <string> > file_struct;

int main(){
    puts("AssetPathsManifest Extractor made by H3x4n1um version 2.3.1");
    puts("Usage: put this file to the same folder you put the AssetPathsManifest");
    puts("Credits: nlohmann for his awesome JSON parser\n");

    /*Read AssetPathsManifest*/
    try{
        input.open("AssetPathsManifest");
        input >> js;
        input.close();
    }
    catch (invalid_argument e){
        _error();
        return 1;
    }

    try{
        /*Extract file name for PvZH AB Download*/
        output.open("PvZH AB Download.txt");
        output << generate_info;
        for (auto i : js.at("BundleNameToDetails").get<map <string, json> >()){
            output << i.first << endl;
            if (i.first.find('/') != string::npos) file_struct[i.first.substr(0, i.first.find('/'))].push_back(i.first.substr(i.first.find('/') + 1, i.first.size() - i.first.find('/') + 1));
            else file_struct["not_in_folder"].push_back(i.first);
        }
        output.close();

        /*Generate "verions"*/
        output.open("versions");
        versions["Comment"] = "This file was generated by AssetPathsManifest Extractor made by H3x4n1um version 2.3.1";
        versions["Entries"] = nullptr;
        for (auto i : js.at("BundleNameToDetails").get<map <string, json> >()){
            string tmp = R"(,{"Name": ")" + i.first + R"(", "Version": )" + to_string(i.second.at("Version").get<int>()) + '}';
            ls = ls + tmp;
        }
        ls.erase(ls.begin());
        versions = versions.patch(json::parse(R"([{"op": "add", "path": "/Entries", "value":[)" + ls + "]}]"));
        output << versions << endl;
        output.close();
    }
    catch (out_of_range e){
        _error();
        return 1;
    }

    //int ans;
    /*Ask if user want to export url*/
    /*printf("Do you want to download those file with IDM? (1 or 0) ");
    cin >> ans;
    if (ans){
        const string OS[] = {"ios", "android"};
        const string branch[] = {"live", "dev"};
        const string folder[] = {
            "not_in_folder",
            "atlastagged",
            "audio",
            "autotagged",
            "cards",
            "config",
            "deck_recipes",
            "fonts",
            "loc",
            "social",
            "store",
            "ui"
        };

        int x, y, z;
        bool beta, platform;
        string link;*/

        /*Extract URL for IDM*/
        /*printf("Which version? (x y z) ");
        scanf("%d%d%d", &x, &y, &z);
        printf("Is it beta? (1 or 0) ");
        cin >> beta;
        printf("Which platform? (1 for Android and 0 for iOS) ");
        cin >> platform;
        link = "https://pvzheroes-" + branch[beta] + ".ecs.popcap.com/assetbundles/" + OS[platform] + '/' + to_string(x) + '.' + to_string(y) + '.' + to_string(z) + '/';

        for (auto i : folder){
            if (i == "not_in_folder") output.open(i + ".txt");
            else{
                string cmd = "mkdir " + i;
                system(cmd.c_str());
                output.open(i + '/' + i + ".txt");
            }
            output << generate_info;
            for (auto j : file_struct[i]){
                if (i == "not_in_folder") output << link << j << endl;
                else output << link << i << '/' << j << endl;
            }
            output.close();
        }
    }*/
    puts("Done!\n");
    system("pause");
    return 0;
}
